{"meta":{"title":"AnChunLi's Bolg","subtitle":null,"description":"记录自己技术的成长，总结过去，展望未来！","author":"lianchun","url":"https://AnChunLi.github.io","root":"/"},"pages":[],"posts":[{"title":"实习面试失败经历","slug":"实习面试失败经历","date":"2019-06-04T15:29:45.000Z","updated":"2019-06-04T15:30:34.601Z","comments":true,"path":"2019/06/04/实习面试失败经历/","link":"","permalink":"https://AnChunLi.github.io/2019/06/04/实习面试失败经历/","excerpt":"","text":"2019实习面试失败一览本来就预料到实习不好找，但没想到这么不好找，在此记录下失败的几次面试，成功还在未来~ 4月中旬华为面试后，我感觉良好，就一直刚在华为上，没有过多投其他公司。最终全是大厂，面试难度真的感受到了，很惨。最好的二面后就凉了，最差的笔试关都没过，甚是悲惨。 华为是自认为面试比较好的一个，技术面和综面都过了，一直等待消息，差不多等了1个月，最准预料到无果，这时候慌了，想想自己还没有offer，就又开始了投递，也就是现在的状况。先说说之前几次的失败吧，由于好久了，细节大多不记得了，有些问的问题因为各种事也没有很好地记录下来。 华为笔试第一次很惨，但给了面试机会，面试基本ok，之后又补了笔试，600分的笔试只得了100分，问题很明显，就是笔试成绩比较低，然后录用排序，最终无果。需要加强算法。 腾讯提前批3月份那时候，第一次面试就不乐观，当时很多细节不清楚，就协商缓存这种问题都能致命。之后的笔试想想也能知道结果…正式批的时候，笔试还是一如既往的难，笔试失败。到5月中旬，腾讯又给了一次机会，但自己还达不到那种技术水平，就彻底凉凉。 阿里阿里内推的时候，第一面电话面试，答得都还可以，顺利过了一面。到第二面时，首先就是自己手机信号不好的问题，给面试官造成了不好的影响，之后问了一些项目相关的问题，我就回答了自己做的小程序项目，然后面试官问了一些在项目中遇到的问题，以及自己如何解决的，我说了消息服务性能的问题，说自己做的聊天服务性能不够好，就用了腾讯云的解决方案，之前也做了基于websocket的单人聊天室和多人聊天室，说了下大概是的实现原理，然后说了列表加载相关的以及性能优化。之后面试官问了，自己如何学习前端的，以及自己自己对前端这块的理解，说下自己印象比较深的，当时我说了JS原型与原型链，作用域与闭包，异步等知识，然后面试问了自己对于V8引擎相关的理解，我直接有点懵，然后差不多久1个小时过去了，最终回绝了我。在自主投递的时候，笔试后就一直没有收到面试通知，然后到5月下旬有面试官来捞我，最准还是没能捞起我… 百度百度真的很奇怪，我笔试过后，一直就没消息了..。按理笔试不应该挂…然后无后话。 头条头条笔试遇到了问题，然后就差不多凉了，之后又在实习僧投了，但都没过一面，感觉难度基本上和二面差不多。 网易网易（网易游戏）投的时候简历都是随便写的，然后第一志愿简历都没有筛选通过，第二志愿简历通过了，当时是华为面完后的第二天面的网易，自己也没多加准备，结果CSS相关有个问题自己记得有点模糊了，然后问了http无状态怎么解决，我说了cookie、本地存储，以及JWT，然后他就顺着问题JWT细节，问到后面我就不会了，但总体不是很差，最终面试没有通过。 京东问题出在笔试了，后面有次机会，放弃了。 斗鱼当时除了华为，我觉得最有信心的就是斗鱼了。笔试顺利通过，没有考算法。面试之前没有复习，然后一开始就慌了，首先问了基础，之后问项目，问代码架构，问自己对新的前端技术的了解。最终无果。 上面全部是在实习生招聘高峰期从官网投的，以下是在第三方网站投的。 滴滴当时投了滴滴前端，然后hr打电话，要我考虑PHP岗位，我说可以。之后面试的确实前端岗。认真准备了，可能是自己准备的还不够全面，就成了惨案。 总结：基础掌握还不够全面，算法需要加强。 期待后续，期待拿offer！","categories":[],"tags":[]},{"title":"滴滴面试惨案","slug":"滴滴面试惨案","date":"2019-06-04T14:17:22.000Z","updated":"2019-06-04T14:23:16.400Z","comments":true,"path":"2019/06/04/滴滴面试惨案/","link":"","permalink":"https://AnChunLi.github.io/2019/06/04/滴滴面试惨案/","excerpt":"","text":"滴滴面试惨案今天是悲惨的一天，精心准备了面试，结果在面试官前输的一败涂地。 首先不得不吐槽校园网，大创的校园网差的要命，面试官从面试软件离开加了我微信，又换了电话面试。 第一题先说面试吧，一上来问了比较基础的问题，考察JS异步，结果我的回答我自己都觉得蠢，那么简单的问题居然能够想错。不过想起来后纠正了，反正印象不太好。123456for(var i=0;i&lt;5;i++)&#123; setTimeout(()=&gt;&#123; console.log(i); &#125;,i*1000)&#125;//说出以上代码的执行结果 看到这个我知道这个考察JS的异步，定时器是异步执行的，但最终会输出5个5，但一开始输出啥，隔几秒钟输出啥，问到这感觉自己懵逼了，不确定自己回答是否正确。最终自己试了知道他会以1S的频率输出5个5。 接着面试官问了，如果保证1,2,3,4,5依次顺次输出，应该怎么写，当时想了半天，想出来用闭包。123456789(function test()&#123; for(var i=0;i&lt;5;i++)&#123; return function()&#123; setTimeout(()=&gt;&#123; console.log(i); &#125;,1000*i) &#125; &#125;&#125;)() 这是当时写的傻逼代码。打开控制台后运行有问题。其实之后发现只要用let就可以完美解决。12345for(let i=0;i&lt;5;i++)&#123; setTimeout(()=&gt;&#123; console.log(i); &#125;,1000*i)&#125; 第二题问了下JS事件环，宏任务与微任务，之前听过相应概念，但自己当时不够重视，没有深入了解，造成失误。Js的事件执行分为宏仁务和微任务 宏仁务主要是由script（全局任务），setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering微任务主要是process.nextTick, Promise.then, Object.observer, MutationObserver.贴段代码，理清楚就行：1234567891011121314151617console.log('main1'); process.nextTick(function() &#123; console.log('process.nextTick1'); &#125;); setTimeout(function() &#123; console.log('setTimeout'); process.nextTick(function() &#123; console.log('process.nextTick2'); &#125;); &#125;, 0); new Promise(function(resolve, reject) &#123; console.log('promise'); resolve(); &#125;).then(function() &#123; console.log('promise then'); &#125;); console.log('main2'); JS代码开始从上往下单线程执行：1.console.log(‘main1’);进入执行栈执行；2.遇到process.nextTick将它的回调函数先放入MicroTask(微任务)；3.遇到setTimeout将它的回调函数放入MacroTask(宏任务队列)；4.在执行栈中new Promise并将.then中注册的回调放入MicroTask(微任务)；5.最后一行代码console.log(‘main2’);会放入主执行栈执行.综上所述，这段代码的结果就是先输出main1，然后第二步第三步我们不用管它，它不是在主执行栈中，所以直接到第四步输出promise，然后主执行栈继续执行第五步输出main2。此时主执行栈执行完毕，开始事件循环，发现在MicroTask中还有任务，开始清空微任务，第二步中我们在微任务中放入了process.nextTick所以输出process.nextTick1，在第四步中将.then的回调放入了微任务，那么微任务队列继续执行输出promise then，此时微任务队列已经清空开始事件循环宏任务队列，也就是输出第三步中的setTimeout，在输出之后发现setTimeout这个回调中还有一个process.nextTick，那么这个回调继续放入微任务队列，此时事件循环发现主执行栈中已经没有任务，那么开始执行MicroTask输出：process.nextTick2 浏览器事件环简单直接：当前栈执行完成（同步代码主线程上执行完成）-&gt;清空微任务-&gt;宏任务队列中的第一项推到栈中执行（如果有微任务，将微任务放入微任务队列）-&gt;清空微任务队列-&gt;宏任务第二项任务执行，依此循环，直到结束。 第三题问了CSS选择器及优先级，当时说了基本的ID选择器、类选择器、元素选择器、属性选择器、子类选择器等等。优先级是：内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器。然后这篇详细讲了优先级的细节，自己也看了下。链接：深入理解CSS选择器优先级 第四题问了盒模型，这个不难，基本答出来了，但问到border-box的使用场景，自己有点不知所措。 content-box缺点当你想让两个子容器float:left，宽度各50%，然后给一点padding，最后让子容器并排充满父容器，一切想的挺美好，然而你发现结果并不是这么美好，因为子容器的盒子宽度已经超出了父容器的一半，导致了折行，于是，width就不能50%了，只能是50%再减去padding的像素值 order-box的优势border-box的诞生，主要就是解决content-box的最大缺点。border-box意味着子容器的padding和border的厚度都算在50%之内，这样，你可以随意的修改padding和border的厚度值，根本不用担心父容器被撑爆。 因此border-box使用场景如下:子元素有padding和border，或者至少有其一，并且需要给子元素设定100%宽度（或者50%宽度等等），这时候显然需要border-box。设为border-box之后，padding和border的厚度可以随意调，并不会溢出父元素。如果是content-box，那么，宽度必然会溢出，而且，为了不溢出，你设定子元素的宽度就只能是一个定值，或者是一个计算值（比如calc(100% - 20px)。 第五题问了http相关的，主要问了301和302，301永久重定向，302暂时重定向。304协商缓存，然后说了下协商缓存的原理。解决减少资源请求方式还有强缓存，如果资源更新了，可以在开始时通过改变Url来重新请求服务器资源，而不是从强缓存中取出，达到了版本更新的目的。另外我回答了PWA等资源本地存储的解决方案。 大概问的问题差不多这几个，还有些回答的ok就没写。总之自己没有对相关知识点进行深入的理解学习，最终酿成这次惨案，想想这么几次面试都挺惨的感觉，总之，加油，早日提高技术吧。","categories":[],"tags":[]},{"title":"js函数节流与防抖","slug":"js函数节流与防抖","date":"2019-06-04T04:55:04.000Z","updated":"2019-06-04T05:04:35.839Z","comments":true,"path":"2019/06/04/js函数节流与防抖/","link":"","permalink":"https://AnChunLi.github.io/2019/06/04/js函数节流与防抖/","excerpt":"","text":"JS函数节流与防抖节流在浏览器resize。scrool等高频率事件，可通过函数节流进行性能优化节流是保证间隔时间内函数只执行一次 代码实现1234567891011121314151617// 节流function throttle(fn,wait)&#123; let timeout; return function()&#123; let that=this; let args=arguments; if(!timeout)&#123; timeout=setTimeout(()=&gt;&#123; timeout=null; fn.apply(that,args); &#125;,wait); &#125; &#125;&#125;document.querySelector('body').onmousemove=throttle(function()&#123; console.log(\"test\");&#125;,1000); ####防抖所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 #####代码实现1234567891011121314151617//防抖function debounce(fn,wait)&#123; let timeout; return function()&#123; let that=this; let args=arguments; if(timeout)&#123; clearTimeout(timeout); &#125; timeout=setTimeout(()=&gt;&#123; fn.apply(that,args); &#125;,wait); &#125;&#125;document.querySelector('body').onmousemove=debounce(function()&#123; console.log(\"test\");&#125;,1000);","categories":[],"tags":[]},{"title":"微信小程序canvas总结","slug":"微信小程序canvas总结","date":"2019-05-25T06:52:53.000Z","updated":"2019-05-25T06:56:17.629Z","comments":true,"path":"2019/05/25/微信小程序canvas总结/","link":"","permalink":"https://AnChunLi.github.io/2019/05/25/微信小程序canvas总结/","excerpt":"","text":"微信小程序开发经验总结1.canvas中绘制buffer图片的问题有时候需要动态生成微信小程序码并携带参数，这时候就需要了解微信小程序的API，请求后会给你一张buffer图片；经检验，wx.wx.arrayBufferToBase64此接口失效，得不到数据，几十可以转换成base64图片，模拟器可以绘制，真机依然失效。我经过百度和尝试，有以下解决方案：1.服务端传回base64格式图片，然后前端以这样的方式去掉空格：showImgData = showImgData.replace(/\\ +/g, “”); //去掉空格方法showImgData = showImgData.replace(/[\\r\\n]/g, “”);//showImgData是base64数据然后使用wx.base64ToArrayBuffer这个接口转换为buffer，不需要加base64头部2.使用小程序文件管理APIconst fsm = wx.getFileSystemManager();var showImgData = this.data.qrcode;showImgData = showImgData.replace(/\\ +/g, “”); //去掉空格方法showImgData = showImgData.replace(/[\\r\\n]/g, “”);const buffer = wx.base64ToArrayBuffer(showImgData);const fileName = wx.env.USER_DATA_PATH + ‘/share_img.png’fsm.writeFileSync(fileName, buffer, ‘binary’); 最终以filename去绘制，就OK了","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-05-25T06:18:15.329Z","updated":"2019-05-25T06:18:15.329Z","comments":true,"path":"2019/05/25/hello-world/","link":"","permalink":"https://AnChunLi.github.io/2019/05/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}