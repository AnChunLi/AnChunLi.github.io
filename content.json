{"meta":{"title":"AnChunLi's Bolg","subtitle":null,"description":"记录自己技术的成长，总结过去，展望未来！","author":"lianchun","url":"https://AnChunLi.github.io","root":"/"},"pages":[],"posts":[{"title":"滴滴面试惨案","slug":"滴滴面试惨案","date":"2019-06-04T14:17:22.000Z","updated":"2019-06-04T14:21:56.284Z","comments":true,"path":"2019/06/04/滴滴面试惨案/","link":"","permalink":"https://AnChunLi.github.io/2019/06/04/滴滴面试惨案/","excerpt":"","text":"滴滴面试惨案今天是悲惨的一天，精心准备了面试，结果在面试官前输的一败涂地。 首先不得不吐槽校园网，大创的校园网差的要命，面试官从面试软件离开加了我微信，又换了电话面试。 第一题先说面试吧，一上来问了比较基础的问题，考察JS异步，结果我的回答我自己都觉得蠢，那么简单的问题居然能够想错。不过想起来后纠正了，反正印象不太好。123456for(var i=0;i&lt;5;i++)&#123; setTimeout(()=&gt;&#123; console.log(i); &#125;,i*1000)&#125;//说出以上代码的执行结果 看到这个我知道这个考察JS的异步，定时器是异步执行的，但最终会输出5个5，但一开始输出啥，隔几秒钟输出啥，问到这感觉自己懵逼了，不确定自己回答是否正确。最终自己试了知道他会以1S的频率输出5个5。 接着面试官问了，如果保证1,2,3,4,5依次顺次输出，应该怎么写，当时想了半天，想出来用闭包。123456789(function test()&#123; for(var i=0;i&lt;5;i++)&#123; return function()&#123; setTimeout(()=&gt;&#123; console.log(i); &#125;,1000*i) &#125; &#125;&#125;)() 这是当时写的傻逼代码。打开控制台后运行有问题。其实之后发现只要用let就可以完美解决。12345for(let i=0;i&lt;5;i++)&#123; setTimeout(()=&gt;&#123; console.log(i); &#125;,1000*i)&#125; 第二题问了下JS事件环，宏任务与微任务，之前听过相应概念，但自己当时不够重视，没有深入了解，造成失误。Js的事件执行分为宏仁务和微任务 宏仁务主要是由script（全局任务），setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering微任务主要是process.nextTick, Promise.then, Object.observer, MutationObserver.贴段代码，理清楚就行：1234567891011121314151617console.log('main1'); process.nextTick(function() &#123; console.log('process.nextTick1'); &#125;); setTimeout(function() &#123; console.log('setTimeout'); process.nextTick(function() &#123; console.log('process.nextTick2'); &#125;); &#125;, 0); new Promise(function(resolve, reject) &#123; console.log('promise'); resolve(); &#125;).then(function() &#123; console.log('promise then'); &#125;); console.log('main2'); JS代码开始从上往下单线程执行：1.console.log(‘main1’);进入执行栈执行；2.遇到process.nextTick将它的回调函数先放入MicroTask(微任务)；3.遇到setTimeout将它的回调函数放入MacroTask(宏任务队列)；4.在执行栈中new Promise并将.then中注册的回调放入MicroTask(微任务)；5.最后一行代码console.log(‘main2’);会放入主执行栈执行.综上所述，这段代码的结果就是先输出main1，然后第二步第三步我们不用管它，它不是在主执行栈中，所以直接到第四步输出promise，然后主执行栈继续执行第五步输出main2。此时主执行栈执行完毕，开始事件循环，发现在MicroTask中还有任务，开始清空微任务，第二步中我们在微任务中放入了process.nextTick所以输出process.nextTick1，在第四步中将.then的回调放入了微任务，那么微任务队列继续执行输出promise then，此时微任务队列已经清空开始事件循环宏任务队列，也就是输出第三步中的setTimeout，在输出之后发现setTimeout这个回调中还有一个process.nextTick，那么这个回调继续放入微任务队列，此时事件循环发现主执行栈中已经没有任务，那么开始执行MicroTask输出：process.nextTick2 浏览器事件环简单直接：当前栈执行完成（同步代码主线程上执行完成）-&gt;清空微任务-&gt;宏任务队列中的第一项推到栈中执行（如果有微任务，将微任务放入微任务队列）-&gt;清空微任务队列-&gt;宏任务第二项任务执行，依此循环，直到结束。 第三题问了CSS选择器及优先级，当时说了基本的ID选择器、类选择器、元素选择器、属性选择器、子类选择器等等。优先级是：内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器。然后这篇详细讲了优先级的细节，自己也看了下。链接：深入理解CSS选择器优先级 第四题问了盒模型，这个不难，基本答出来了，但问到border-box的使用场景，自己有点不知所措。 content-box缺点当你想让两个子容器float:left，宽度各50%，然后给一点padding，最后让子容器并排充满父容器，一切想的挺美好，然而你发现结果并不是这么美好，因为子容器的盒子宽度已经超出了父容器的一半，导致了折行，于是，width就不能50%了，只能是50%再减去padding的像素值 order-box的优势border-box的诞生，主要就是解决content-box的最大缺点。border-box意味着子容器的padding和border的厚度都算在50%之内，这样，你可以随意的修改padding和border的厚度值，根本不用担心父容器被撑爆。 因此border-box使用场景如下:子元素有padding和border，或者至少有其一，并且需要给子元素设定100%宽度（或者50%宽度等等），这时候显然需要border-box。设为border-box之后，padding和border的厚度可以随意调，并不会溢出父元素。如果是content-box，那么，宽度必然会溢出，而且，为了不溢出，你设定子元素的宽度就只能是一个定值，或者是一个计算值（比如calc(100% - 20px)。 第五题问了http相关的，主要问了301和302，301永久重定向，302暂时重定向。304协商缓存，然后说了下协商缓存的原理。解决减少资源请求方式还有强缓存，如果资源更新了，可以在开始时通过改变Url来重新请求服务器资源，而不是从强缓存中取出，达到了版本更新的目的。另外我回答了PWA等资源本地存储的解决方案。 大概问的问题差不多这几个，还有些回答的ok就没写。总之自己没有对相关知识点进行深入的理解学习，最终酿成这次惨案，想想这么几次面试都挺惨的感觉，总之，加油，早日提高技术吧。","categories":[],"tags":[]},{"title":"js函数节流与防抖","slug":"js函数节流与防抖","date":"2019-06-04T04:55:04.000Z","updated":"2019-06-04T05:04:35.839Z","comments":true,"path":"2019/06/04/js函数节流与防抖/","link":"","permalink":"https://AnChunLi.github.io/2019/06/04/js函数节流与防抖/","excerpt":"","text":"JS函数节流与防抖节流在浏览器resize。scrool等高频率事件，可通过函数节流进行性能优化节流是保证间隔时间内函数只执行一次 代码实现1234567891011121314151617// 节流function throttle(fn,wait)&#123; let timeout; return function()&#123; let that=this; let args=arguments; if(!timeout)&#123; timeout=setTimeout(()=&gt;&#123; timeout=null; fn.apply(that,args); &#125;,wait); &#125; &#125;&#125;document.querySelector('body').onmousemove=throttle(function()&#123; console.log(\"test\");&#125;,1000); ####防抖所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 #####代码实现1234567891011121314151617//防抖function debounce(fn,wait)&#123; let timeout; return function()&#123; let that=this; let args=arguments; if(timeout)&#123; clearTimeout(timeout); &#125; timeout=setTimeout(()=&gt;&#123; fn.apply(that,args); &#125;,wait); &#125;&#125;document.querySelector('body').onmousemove=debounce(function()&#123; console.log(\"test\");&#125;,1000);","categories":[],"tags":[]},{"title":"微信小程序canvas总结","slug":"微信小程序canvas总结","date":"2019-05-25T06:52:53.000Z","updated":"2019-05-25T06:56:17.629Z","comments":true,"path":"2019/05/25/微信小程序canvas总结/","link":"","permalink":"https://AnChunLi.github.io/2019/05/25/微信小程序canvas总结/","excerpt":"","text":"微信小程序开发经验总结1.canvas中绘制buffer图片的问题有时候需要动态生成微信小程序码并携带参数，这时候就需要了解微信小程序的API，请求后会给你一张buffer图片；经检验，wx.wx.arrayBufferToBase64此接口失效，得不到数据，几十可以转换成base64图片，模拟器可以绘制，真机依然失效。我经过百度和尝试，有以下解决方案：1.服务端传回base64格式图片，然后前端以这样的方式去掉空格：showImgData = showImgData.replace(/\\ +/g, “”); //去掉空格方法showImgData = showImgData.replace(/[\\r\\n]/g, “”);//showImgData是base64数据然后使用wx.base64ToArrayBuffer这个接口转换为buffer，不需要加base64头部2.使用小程序文件管理APIconst fsm = wx.getFileSystemManager();var showImgData = this.data.qrcode;showImgData = showImgData.replace(/\\ +/g, “”); //去掉空格方法showImgData = showImgData.replace(/[\\r\\n]/g, “”);const buffer = wx.base64ToArrayBuffer(showImgData);const fileName = wx.env.USER_DATA_PATH + ‘/share_img.png’fsm.writeFileSync(fileName, buffer, ‘binary’); 最终以filename去绘制，就OK了","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-05-25T06:18:15.329Z","updated":"2019-05-25T06:18:15.329Z","comments":true,"path":"2019/05/25/hello-world/","link":"","permalink":"https://AnChunLi.github.io/2019/05/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}